package router

import (
	"bufio"
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"log/slog"
	"net/http"
	"os"
	"regexp"
	"strings"
	"sync"
	"text/template"
	"time"

	"github.com/strct-org/strct-agent/internal/config"
	"github.com/strct-org/strct-agent/internal/platform/executil"
)

type Config struct {
	DeviceID   string
	BackendURL string
}

type PortRule struct {
	ID       string `json:"id"`
	Name     string `json:"name"`
	Port     int    `json:"port"`
	DeviceIP string `json:"device_ip"`
	Protocol string `json:"protocol"` // TCP, UDP, BOTH
}

type RouterConfig struct {
	SSID            string     `json:"ssid"`
	Password        string     `json:"password"`
	SecurityMode    string     `json:"security_mode"`    // "WPA2" | "WPA3"
	IsHidden        bool       `json:"is_hidden"`        // ignore_broadcast_ssid=1
	Frequency       string     `json:"frequency"`        // "2.4GHz" | "5GHz"
	Channel         int        `json:"channel"`          // 1/6/11 for 2.4; 36/40/44/48 for 5
	TxPower         string     `json:"tx_power"`         // "20" | "30" → iwconfig wlan0 txpower
	MaxClients      int        `json:"max_clients"`      // max_num_sta in hostapd
	DNSProvider     string     `json:"dns_provider"`     // cloudflare|google|adguard|quad9|isp
	FirewallEnabled bool       `json:"firewall_enabled"` // -P INPUT DROP
	GuestIsolation  bool       `json:"guest_isolation"`  // FORWARD -i wlan0 -o wlan0 DROP
	BlockPing       bool       `json:"block_ping"`       // -A INPUT -p icmp -j DROP
	IPv6Firewall    bool       `json:"ipv6_firewall"`    // ip6tables -P INPUT DROP
	PortRules       []PortRule `json:"port_rules"`
}

type ConnectedDevice struct {
	ID        string  `json:"id"`
	IP        string  `json:"ip"`
	MAC       string  `json:"mac"`
	Name      string  `json:"name"`
	Blocked   bool    `json:"blocked"`
	Limited   bool    `json:"limited"`
	LimitMbps float64 `json:"limit_mbps"`
}

type RouterController struct {
	cfg         Config
	state       RouterConfig
	devices     []ConnectedDevice
	mu          sync.RWMutex
	blockedMACs map[string]bool
	limitedMACs map[string]float64
	client      *http.Client
	cmd         executil.Runner
}

const hostapdTemplate = `# Generated by strct-agent — do not edit manually
interface=wlan0
driver=nl80211
ssid={{.SSID}}
{{- if eq .Frequency "5GHz"}}
hw_mode=a
{{- else}}
hw_mode=g
{{- end}}
channel={{.Channel}}
country_code=US
ieee80211d=1
ieee80211n=1
ieee80211ac=1
wmm_enabled=1
{{- if eq .SecurityMode "WPA3"}}
wpa=3
wpa_key_mgmt=SAE
ieee80211w=2
{{- else}}
wpa=2
wpa_key_mgmt=WPA-PSK
{{- end}}
wpa_passphrase={{.Password}}
rsn_pairwise=CCMP
ignore_broadcast_ssid={{if .IsHidden}}1{{else}}0{{end}}
max_num_sta={{.MaxClients}}
`
func New(cfg Config, cmd executil.Runner) *RouterController {
	return &RouterController{
		cfg: cfg,
		state: RouterConfig{
			SSID:            "OrangePi_AP",
			Password:        "orange123",
			SecurityMode:    "WPA3",
			Frequency:       "5GHz",
			Channel:         36,
			TxPower:         "20",
			MaxClients:      20,
			DNSProvider:     "cloudflare",
			FirewallEnabled: true,
			GuestIsolation:  false,
			BlockPing:       false,
			IPv6Firewall:    false,
			PortRules:       []PortRule{},
		},
		devices:     []ConnectedDevice{},
		blockedMACs: make(map[string]bool),
		limitedMACs: make(map[string]float64),
		cmd:         cmd,
		client: &http.Client{
			Timeout: 10 * time.Second,
			Transport: &http.Transport{
				MaxIdleConnsPerHost: 2,
				IdleConnTimeout:     90 * time.Second,
			},
		},
	}
}

func NewDefault(cfg Config) *RouterController {
	return New(cfg, executil.Real{})
}

func NewFromConfig(cfg *config.Config) *RouterController {
	return NewDefault(Config{
		DeviceID:   cfg.DeviceID,
		BackendURL: cfg.EffectiveBackendURL(),
	})
}

func (rc *RouterController) RegisterRoutes(mux *http.ServeMux) {
	mux.HandleFunc("GET /api/router/config", rc.handleGetConfig)
	mux.HandleFunc("POST /api/router/config", rc.handleSetConfig)
	mux.HandleFunc("GET /api/router/devices", rc.handleGetDevices)
	mux.HandleFunc("POST /api/router/block", rc.handleBlockDevice)
	mux.HandleFunc("POST /api/router/limit", rc.handleLimitDevice)
}

func (rc *RouterController) Start(ctx context.Context) error {
	slog.Info("router: starting")

	if err := rc.applyAll(); err != nil {
		slog.Warn("router: initial apply had errors", "err", err)
	}

	go func() {
		ticker := time.NewTicker(10 * time.Second)
		defer ticker.Stop()
		for {
			select {
			case <-ctx.Done():
				slog.Info("router: stopped")
				return
			case <-ticker.C:
				rc.scanDevices()
			}
		}
	}()

	return nil
}

func (rc *RouterController) handleGetConfig(w http.ResponseWriter, r *http.Request) {
	rc.mu.RLock()
	state := rc.state // copy under lock
	rc.mu.RUnlock()

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(state)
}

func (rc *RouterController) handleSetConfig(w http.ResponseWriter, r *http.Request) {
	var newConfig RouterConfig
	if err := json.NewDecoder(r.Body).Decode(&newConfig); err != nil {
		http.Error(w, "invalid JSON", http.StatusBadRequest)
		return
	}

	// Basic validation
	if newConfig.SSID == "" || len(newConfig.Password) < 8 {
		http.Error(w, "ssid required and password must be >= 8 chars", http.StatusBadRequest)
		return
	}
	if newConfig.Channel == 0 {
		newConfig.Channel = 36
	}
	if newConfig.MaxClients == 0 {
		newConfig.MaxClients = 20
	}

	rc.mu.Lock()
	rc.state = newConfig
	rc.mu.Unlock()

	// Apply asynchronously — don't block the HTTP response
	go func() {
		if err := rc.applyAll(); err != nil {
			slog.Error("router: apply failed", "err", err)
		}
	}()

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]string{"status": "applying"})
}

func (rc *RouterController) handleGetDevices(w http.ResponseWriter, r *http.Request) {
	rc.mu.RLock()
	devices := rc.devices
	rc.mu.RUnlock()

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(devices)
}

// handleBlockDevice toggles iptables DROP rules for a specific MAC.
// POST body: {"mac":"XX:XX:XX:XX:XX:XX","block":true}
// Runs iptables OUTSIDE the mutex — holding a write lock during exec is
// the bug identified in audit issue #3.
func (rc *RouterController) handleBlockDevice(w http.ResponseWriter, r *http.Request) {
	var req struct {
		MAC   string `json:"mac"`
		Block bool   `json:"block"`
	}
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "invalid JSON", http.StatusBadRequest)
		return
	}

	// Validate MAC format before passing to iptables
	if !validMAC(req.MAC) {
		http.Error(w, "invalid MAC address", http.StatusBadRequest)
		return
	}

	// Update state first (fast, under lock)
	rc.mu.Lock()
	if req.Block {
		rc.blockedMACs[req.MAC] = true
	} else {
		delete(rc.blockedMACs, req.MAC)
	}
	rc.mu.Unlock()

	// Run iptables OUTSIDE the lock — these can take hundreds of milliseconds
	// and would deadlock readers if held under mu.
	var err error
	if req.Block {
		err = rc.blockMAC(req.MAC)
	} else {
		err = rc.unblockMAC(req.MAC)
	}
	if err != nil {
		slog.Error("router: iptables block failed", "mac", req.MAC, "err", err)
		http.Error(w, "iptables error", http.StatusInternalServerError)
		return
	}

	go rc.scanDevices()
	w.WriteHeader(http.StatusOK)
}

// handleLimitDevice sets or removes a tc htb bandwidth limit for a device IP.
// POST body: {"mac":"XX:XX:XX:XX:XX:XX","ip":"192.168.1.x","limit_mbps":5}
// limit_mbps=0 removes the limit.
func (rc *RouterController) handleLimitDevice(w http.ResponseWriter, r *http.Request) {
	var req struct {
		MAC       string  `json:"mac"`
		IP        string  `json:"ip"`
		LimitMbps float64 `json:"limit_mbps"`
	}
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "invalid JSON", http.StatusBadRequest)
		return
	}
	if !validMAC(req.MAC) || req.IP == "" {
		http.Error(w, "invalid MAC or IP", http.StatusBadRequest)
		return
	}

	rc.mu.Lock()
	if req.LimitMbps > 0 {
		rc.limitedMACs[req.MAC] = req.LimitMbps
	} else {
		delete(rc.limitedMACs, req.MAC)
	}
	rc.mu.Unlock()

	// tc commands run outside lock
	var err error
	if req.LimitMbps > 0 {
		err = rc.setTCLimit(req.IP, req.LimitMbps)
	} else {
		err = rc.removeTCLimit(req.IP)
	}
	if err != nil {
		slog.Warn("router: tc limit failed", "ip", req.IP, "err", err)
		// Non-fatal — respond OK, tc may not be available on all kernels
	}

	w.WriteHeader(http.StatusOK)
}

func (rc *RouterController) applyAll() error {
	var errs []string

	if err := rc.applyHostapd(); err != nil {
		errs = append(errs, fmt.Sprintf("hostapd: %v", err))
	}
	if err := rc.applyDNS(); err != nil {
		errs = append(errs, fmt.Sprintf("dns: %v", err))
	}
	if err := rc.applyFirewall(); err != nil {
		errs = append(errs, fmt.Sprintf("firewall: %v", err))
	}
	if err := rc.applyPortForwarding(); err != nil {
		errs = append(errs, fmt.Sprintf("ports: %v", err))
	}
	if err := rc.applyTxPower(); err != nil {
		errs = append(errs, fmt.Sprintf("txpower: %v", err))
	}

	if len(errs) > 0 {
		return fmt.Errorf("apply errors: %s", strings.Join(errs, "; "))
	}
	return nil
}

func (rc *RouterController) applyHostapd() error {
	rc.mu.RLock()
	cfg := rc.state
	rc.mu.RUnlock()

	tmpl, err := template.New("hostapd").Parse(hostapdTemplate)
	if err != nil {
		return fmt.Errorf("template parse: %w", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, cfg); err != nil {
		return fmt.Errorf("template execute: %w", err)
	}

	if err := os.WriteFile("/etc/hostapd/hostapd.conf", buf.Bytes(), 0600); err != nil {
		return fmt.Errorf("write hostapd.conf: %w", err)
	}

	if err := rc.cmd.Run("systemctl", "kill", "-s", "HUP", "hostapd"); err != nil {
		slog.Warn("router: hostapd HUP failed, doing full restart", "err", err)
		if err := rc.cmd.Run("systemctl", "restart", "hostapd"); err != nil {
			return fmt.Errorf("restart hostapd: %w", err)
		}
	}

	slog.Info("router: hostapd config applied", "ssid", cfg.SSID, "band", cfg.Frequency, "channel", cfg.Channel)
	return nil
}

// applyDNS writes /etc/resolv.conf with the selected nameserver.
//
//	DNS providers:
//	  cloudflare → 1.1.1.1 + 1.0.0.1
//	  google     → 8.8.8.8 + 8.8.4.4
//	  adguard    → 94.140.14.14 + 94.140.15.15  (ad blocking)
//	  quad9      → 9.9.9.9 + 149.112.112.112    (malware blocking)
//	  isp        → reset via dhclient
func (rc *RouterController) applyDNS() error {
	rc.mu.RLock()
	provider := rc.state.DNSProvider
	rc.mu.RUnlock()

	type dnsEntry struct{ primary, secondary string }
	providers := map[string]dnsEntry{
		"cloudflare": {"1.1.1.1", "1.0.0.1"},
		"google":     {"8.8.8.8", "8.8.4.4"},
		"adguard":    {"94.140.14.14", "94.140.15.15"},
		"quad9":      {"9.9.9.9", "149.112.112.112"},
	}

	if provider == "isp" {
		// Reset to DHCP-provided DNS
		return rc.cmd.Run("dhclient", "-r")
	}

	entry, ok := providers[provider]
	if !ok {
		entry = providers["cloudflare"]
	}

	content := fmt.Sprintf("nameserver %s\nnameserver %s\n", entry.primary, entry.secondary)
	if err := os.WriteFile("/etc/resolv.conf", []byte(content), 0644); err != nil {
		return fmt.Errorf("write resolv.conf: %w", err)
	}

	slog.Info("router: DNS applied", "provider", provider, "primary", entry.primary)
	return nil
}

// applyFirewall rebuilds the iptables ruleset from scratch.
// Flush → set policy → add stateful rules → apply optional rules.
//
//	firewall_enabled → -P INPUT DROP (only ESTABLISHED,RELATED allowed)
//	guest_isolation  → -A FORWARD -i wlan0 -o wlan0 -j DROP
//	block_ping       → -A INPUT -p icmp -j DROP
//	ipv6_firewall    → ip6tables -P INPUT DROP
func (rc *RouterController) applyFirewall() error {
	rc.mu.RLock()
	cfg := rc.state
	rc.mu.RUnlock()

	// Flush existing rules to start clean
	rc.cmd.Run("iptables", "-F")
	rc.cmd.Run("iptables", "-X")

	if cfg.FirewallEnabled {
		// Allow established/related connections first (critical — without this
		// we'd drop all replies to connections we initiated)
		rc.cmd.Run("iptables", "-A", "INPUT", "-m", "state", "--state", "ESTABLISHED,RELATED", "-j", "ACCEPT")
		rc.cmd.Run("iptables", "-A", "INPUT", "-i", "lo", "-j", "ACCEPT")
		rc.cmd.Run("iptables", "-P", "INPUT", "DROP")
	} else {
		rc.cmd.Run("iptables", "-P", "INPUT", "ACCEPT")
	}

	if cfg.GuestIsolation {
		// Prevent devices on wlan0 from talking to each other directly
		// (they can still reach the internet through the router)
		rc.cmd.Run("iptables", "-A", "FORWARD", "-i", "wlan0", "-o", "wlan0", "-j", "DROP")
	}

	if cfg.BlockPing {
		rc.cmd.Run("iptables", "-A", "INPUT", "-p", "icmp", "--icmp-type", "echo-request", "-j", "DROP")
	}

	// Re-apply per-device MAC blocks (they were flushed above)
	rc.mu.RLock()
	for mac := range rc.blockedMACs {
		rc.mu.RUnlock()
		rc.blockMAC(mac) //nolint:errcheck
		rc.mu.RLock()
	}
	rc.mu.RUnlock()

	if cfg.IPv6Firewall {
		rc.cmd.Run("ip6tables", "-P", "INPUT", "DROP")
		rc.cmd.Run("ip6tables", "-A", "INPUT", "-m", "state", "--state", "ESTABLISHED,RELATED", "-j", "ACCEPT")
		rc.cmd.Run("ip6tables", "-A", "INPUT", "-i", "lo", "-j", "ACCEPT")
	}

	slog.Info("router: firewall applied",
		"block_incoming", cfg.FirewallEnabled,
		"guest_isolation", cfg.GuestIsolation,
		"block_ping", cfg.BlockPing,
	)
	return nil
}

// applyPortForwarding rebuilds NAT PREROUTING rules for all port rules.
//
//	For each rule:
//	  iptables -t nat -A PREROUTING -p tcp --dport PORT -j DNAT --to-destination IP:PORT
//	  iptables -A FORWARD -p tcp -d IP --dport PORT -j ACCEPT
//	  iptables -t nat -A POSTROUTING -j MASQUERADE
func (rc *RouterController) applyPortForwarding() error {
	rc.mu.RLock()
	rules := rc.state.PortRules
	rc.mu.RUnlock()

	// Flush existing port forwarding rules
	rc.cmd.Run("iptables", "-t", "nat", "-F", "PREROUTING")
	rc.cmd.Run("iptables", "-F", "FORWARD")

	for _, rule := range rules {
		dest := fmt.Sprintf("%s:%d", rule.DeviceIP, rule.Port)
		portStr := fmt.Sprintf("%d", rule.Port)
		protos := []string{strings.ToLower(rule.Protocol)}
		if strings.ToLower(rule.Protocol) == "both" {
			protos = []string{"tcp", "udp"}
		}

		for _, proto := range protos {
			rc.cmd.Run("iptables", "-t", "nat", "-A", "PREROUTING",
				"-p", proto, "--dport", portStr,
				"-j", "DNAT", "--to-destination", dest)
			rc.cmd.Run("iptables", "-A", "FORWARD",
				"-p", proto, "-d", rule.DeviceIP, "--dport", portStr,
				"-j", "ACCEPT")
		}
	}

	// MASQUERADE ensures reply packets route back correctly
	rc.cmd.Run("iptables", "-t", "nat", "-A", "POSTROUTING", "-j", "MASQUERADE")

	// Enable IP forwarding (required for NAT)
	os.WriteFile("/proc/sys/net/ipv4/ip_forward", []byte("1"), 0644) //nolint:errcheck

	slog.Info("router: port forwarding applied", "rules", len(rules))
	return nil
}

// applyTxPower sets the WiFi transmit power.
//
//	iwconfig wlan0 txpower 30   (Signal Boost: 30 dBm)
//	iwconfig wlan0 txpower 20   (Normal: 20 dBm)
func (rc *RouterController) applyTxPower() error {
	rc.mu.RLock()
	txPower := rc.state.TxPower
	rc.mu.RUnlock()

	if err := rc.cmd.Run("iwconfig", "wlan0", "txpower", txPower); err != nil {
		return fmt.Errorf("iwconfig txpower %s: %w", txPower, err)
	}
	slog.Info("router: TX power set", "dbm", txPower)
	return nil
}

// ─── Per-device iptables helpers (run OUTSIDE any mutex) ─────────────────────

// blockMAC adds INPUT and FORWARD DROP rules for a MAC address.
//
//	iptables -A INPUT   -m mac --mac-source MAC -j DROP
//	iptables -A FORWARD -m mac --mac-source MAC -j DROP
func (rc *RouterController) blockMAC(mac string) error {
	if err := rc.cmd.Run("iptables", "-A", "INPUT", "-m", "mac", "--mac-source", mac, "-j", "DROP"); err != nil {
		return fmt.Errorf("block INPUT: %w", err)
	}
	if err := rc.cmd.Run("iptables", "-A", "FORWARD", "-m", "mac", "--mac-source", mac, "-j", "DROP"); err != nil {
		return fmt.Errorf("block FORWARD: %w", err)
	}
	slog.Info("router: device blocked", "mac", mac)
	return nil
}

// unblockMAC deletes the DROP rules for a MAC address.
//
//	iptables -D INPUT   -m mac --mac-source MAC -j DROP
//	iptables -D FORWARD -m mac --mac-source MAC -j DROP
func (rc *RouterController) unblockMAC(mac string) error {
	rc.cmd.Run("iptables", "-D", "INPUT", "-m", "mac", "--mac-source", mac, "-j", "DROP")   //nolint:errcheck
	rc.cmd.Run("iptables", "-D", "FORWARD", "-m", "mac", "--mac-source", mac, "-j", "DROP") //nolint:errcheck
	slog.Info("router: device unblocked", "mac", mac)
	return nil
}

// setTCLimit applies a bandwidth rate limit to a device IP using Linux tc (traffic control).
//
//	tc qdisc add dev wlan0 root handle 1: htb default 999
//	tc class add dev wlan0 parent 1: classid 1:1 htb rate RATE burst 15k
//	tc filter add dev wlan0 parent 1:0 protocol ip u32 match ip dst IP/32 flowid 1:1
//
// Note: this is a simplified single-class HTB. In production you'd want a
// class per device so limits don't interfere with each other.
func (rc *RouterController) setTCLimit(ip string, mbps float64) error {
	rate := fmt.Sprintf("%.2fmbit", mbps)

	// Set up root qdisc if not already present
	rc.cmd.Run("tc", "qdisc", "del", "dev", "wlan0", "root") //nolint:errcheck — may not exist
	if err := rc.cmd.Run("tc", "qdisc", "add", "dev", "wlan0", "root", "handle", "1:", "htb", "default", "999"); err != nil {
		return fmt.Errorf("tc qdisc: %w", err)
	}

	// Root class (unlimited — parent for all limited classes)
	rc.cmd.Run("tc", "class", "add", "dev", "wlan0", "parent", "1:", "classid", "1:999", "htb", "rate", "1000mbit") //nolint:errcheck

	// Per-device limited class
	if err := rc.cmd.Run("tc", "class", "add", "dev", "wlan0", "parent", "1:", "classid", "1:1", "htb", "rate", rate, "burst", "15k"); err != nil {
		return fmt.Errorf("tc class: %w", err)
	}

	// Filter: match traffic destined for this IP → limited class
	if err := rc.cmd.Run("tc", "filter", "add", "dev", "wlan0",
		"parent", "1:0", "protocol", "ip",
		"u32", "match", "ip", "dst", ip+"/32",
		"flowid", "1:1"); err != nil {
		return fmt.Errorf("tc filter: %w", err)
	}

	slog.Info("router: bandwidth limit set", "ip", ip, "rate", rate)
	return nil
}

// removeTCLimit removes all tc rules from the wlan0 interface.
func (rc *RouterController) removeTCLimit(ip string) error {
	// Simplified: remove entire qdisc. In production you'd delete only
	// the specific class and filter for this IP.
	if err := rc.cmd.Run("tc", "qdisc", "del", "dev", "wlan0", "root"); err != nil {
		return fmt.Errorf("tc del: %w", err)
	}
	slog.Info("router: bandwidth limit removed", "ip", ip)
	return nil
}

// ─── Device scanning ──────────────────────────────────────────────────────────

// scanDevices reads connected devices using both `arp -a` (layer 2 neighbors)
// and `ip neigh show` for a more complete picture.
//
//	arp -a output: ? (192.168.1.15) at a1:b2:c3:d4:e5:f6 [ether] on wlan0
func (rc *RouterController) scanDevices() {
	out, err := rc.cmd.CombinedOutput("arp", "-a")
	if err != nil {
		slog.Error("router: arp scan failed", "err", err)
		return
	}

	re := regexp.MustCompile(`\(([\d.]+)\) at ([0-9a-f:]{17})`)
	scanner := bufio.NewScanner(bytes.NewReader(out))
	var detected []ConnectedDevice

	rc.mu.RLock()
	blocked := rc.blockedMACs
	limited := rc.limitedMACs
	rc.mu.RUnlock()

	for scanner.Scan() {
		m := re.FindStringSubmatch(scanner.Text())
		if len(m) != 3 {
			continue
		}
		ip, mac := m[1], m[2]

		limitMbps := limited[mac]
		detected = append(detected, ConnectedDevice{
			ID:        mac,
			IP:        ip,
			MAC:       mac,
			Name:      "Unknown Device", // hostname lookup via reverse DNS if needed
			Blocked:   blocked[mac],
			Limited:   limitMbps > 0,
			LimitMbps: limitMbps,
		})
	}

	rc.mu.Lock()
	rc.devices = detected
	rc.mu.Unlock()

	go rc.reportDevicesToBackend(detected)
}

func (rc *RouterController) reportDevicesToBackend(devices []ConnectedDevice) {
	url := fmt.Sprintf("%s/api/v1/device/agent/%s/connected_devices",
		rc.cfg.BackendURL, rc.cfg.DeviceID)

	payload, err := json.Marshal(devices)
	if err != nil {
		return
	}

	req, err := http.NewRequest(http.MethodPost, url, bytes.NewBuffer(payload))
	if err != nil {
		return
	}
	req.Header.Set("Content-Type", "application/json")

	resp, err := rc.client.Do(req)
	if err != nil {
		slog.Error("router: backend report failed", "err", err)
		return
	}
	defer resp.Body.Close()
	io.Copy(io.Discard, resp.Body) //nolint:errcheck

	if resp.StatusCode >= 400 {
		slog.Warn("router: backend rejected devices report", "status", resp.StatusCode)
	}
}

var macRegexp = regexp.MustCompile(`^([0-9A-Fa-f]{2}:){5}[0-9A-Fa-f]{2}$`)

func validMAC(mac string) bool {
	return macRegexp.MatchString(mac)
}
